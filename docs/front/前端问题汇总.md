# 前端问题汇总

## Ajax/Fetch/Axios 区别

1. Ajax，一种技术统称
2. Fetch，一个原生API
3. Axios，一个第三方库

## 防抖和节流区别

代码见 `Javascript.md`

**防抖**：

1. 点击后延迟一段时间执行，延迟时间内点击重置延迟，最终以最后一次点击为准
2. “你先抖着，啥时候停了，再执行下一步”
3. 比如搜索输入框，输入停止后再执行搜索
4. 限制执行次数，多次密集的触发只执行一次

**节流**：

1. 点击后延迟一段时间执行，延迟时间内点击被忽略，最终以第一次点击为准
2. “一个一个来，按时间节奏来，插队的无效”
3. 比如 drag/scroll 时一段时间内只触发一次回调
4. 限制执行频率，有节奏的执行

## 箭头函数的缺点，哪里不适用

**缺点**：

1. 没有 arguments
2. 无法用 call/apply/bind 绑定 this
3. 不易于阅读

**以下情况会取不到 this**：

1. 对象方法，比如 `{ foo: () => {} }`
2. 原型方法，比如 `x.prototype.foo = () => {}`
3. 构造函数，比如 `const foo = () => {}`
4. 动态上下文中的回调，比如 `addEventListener('click', () => {}')`
5. Vue 的生命周期和 method，本质上和第一点一样(PS：Class 中的箭头函数能获取到 this)、

## 描述TCP三次握手和四次挥手

详细流程见 `tcp.md`

建立 TCP 连接：

1. 先建立连接(确保双方都有收发消息的能力)
2. 再传输内容(如传输给一个 get 请求)
3. 网络连接是 TCP 协议，传输内容是 HTTP 协议

三次握手 -- 建立连接：

1. Client 发 syn 包，Server 接收。Server：有 Client 请求
2. Server 发 syn + ack 包，Client 接收。Client：Server 已经收到消息
3. Client 发 ack 包，Server 接收。Server：Client 要准备发送

四次握手 -- 关闭连接：

1. Client 发 fin 包，Server 接收。Server：Client 已请求结束
2. Server 发 ack 包，Client 接收。Client：Server 准备停发包，但还有一些尾包得发完
3. Server 发 fin 包，Client 接收。Client：Server 全部发完，可以关闭连接
4. Client 发 ack 包，Server 接收。Server：Server 关闭连接

为什么挥手是四次？

虽然第二步服务端说了不再发送，但可能还会发送尾包，所以需要第三步去最终确认

## for...in 和 for...of 区别

1. 遍历对象：前者可以，后者不行
2. 遍历 Map/Set：前者不行，后者可以
3. 遍历 generator：前者不行，后者可以
4. 遍历数组/字符串：两者都可以

简而言之:

1. 前者遍历得到 key，后者遍历得到 value
2. 前者用于 **可枚举** 数据，后者用于 **可迭代** 数据

## for await... of 有什么用

用于遍历多个 Promise

```js
async function fn() {
  for await (let res of promises) {
    console.log(res)
  }
}
```

## offsetHeight/clientHeight/scrollHeight

offsetHeight = padding + content + border

clientHeight = padding + content

scrollHeight = padding + 实际内容尺寸

## HTMLCollection 和 NodeList 区别

1. DOM 是一棵树，所有节点都是 Node
2. Node 是 Element 的基类
3. Element 是其他 HTML 元素的基类

```js
class Node {}

// document
class Document extends Node {}
class DocumentFragment extends Node {}

// 文本和注释
class CharacterData extends Node {}
class Text extends CharacterData {}
class Comment extends CharacterData {}

// element
class Element extends Node {}
class HTMLElement extends Element {}
class HTMLDivElement extends HTMLElement {}
class HTMLButtonElement extends HTMLElement {}

const p = document.querySelector('p')
console.log(p.children instanceof HTMLCollection) // true
console.log(p.childNodes instanceof NodeList) // true

```

前者是 Element 的集合，后者是 Node 的集合

两者都是类数组，可以用 `Array.from(list)` / `Array.prototype.slice.call(list)` / `[...list]` 转换为数组

## 严格模式有什么特点

1. 全局变量必须先声明
2. 禁止用 with
3. 创建 eval 作用域
4. 禁止 this 指向 window
5. 函数参数不能重名

## HTTP 跨域请求为什么会发送 Options 请求

跨域请求：

1. 浏览器有同源策略
2. 同源策略一般限制 Ajax 请求，不能跨域请求 server
3. 但是不会限制 link/image/script/iframe 加载第三方资源

Options 请求是跨域请求前的预检查，是浏览器自行发起的，它会检查服务器是否允许跨域，不影响实际功能
