# 前端问题汇总

## Ajax/Fetch/Axios 区别

1. Ajax，一种技术统称
2. Fetch，一个原生API
3. Axios，一个第三方库

## 防抖和节流区别

代码见 `Javascript.md`

**防抖**：

1. 点击后延迟一段时间执行，延迟时间内点击重置延迟，最终以最后一次点击为准
2. “你先抖着，啥时候停了，再执行下一步”
3. 比如搜索输入框，输入停止后再执行搜索
4. 限制执行次数，多次密集的触发只执行一次

**节流**：

1. 点击后延迟一段时间执行，延迟时间内点击被忽略，最终以第一次点击为准
2. “一个一个来，按时间节奏来，插队的无效”
3. 比如 drag/scroll 时一段时间内只触发一次回调
4. 限制执行频率，有节奏的执行

## 箭头函数的缺点，哪里不适用

**缺点**：

1. 没有 arguments
2. 无法用 call/apply/bind 绑定 this
3. 不易于阅读

**以下情况会取不到 this**：

1. 对象方法，比如 `{ foo: () => {} }`
2. 原型方法，比如 `x.prototype.foo = () => {}`
3. 构造函数，比如 `const foo = () => {}`
4. 动态上下文中的回调，比如 `addEventListener('click', () => {}')`
5. Vue 的生命周期和 method，本质上和第一点一样(PS：Class 中的箭头函数能获取到 this)、

## 描述TCP三次握手和四次挥手

详细流程见 `tcp.md`

建立 TCP 连接：

1. 先建立连接(确保双方都有收发消息的能力)
2. 再传输内容(如传输给一个 get 请求)
3. 网络连接是 TCP 协议，传输内容是 HTTP 协议

三次握手 -- 建立连接：

1. Client 发 syn 包，Server 接收。Server：有 Client 请求
2. Server 发 syn + ack 包，Client 接收。Client：Server 已经收到消息
3. Client 发 ack 包，Server 接收。Server：Client 要准备发送

四次握手 -- 关闭连接：

1. Client 发 fin 包，Server 接收。Server：Client 已请求结束
2. Server 发 ack 包，Client 接收。Client：Server 准备停发包，但还有一些尾包得发完
3. Server 发 fin 包，Client 接收。Client：Server 全部发完，可以关闭连接
4. Client 发 ack 包，Server 接收。Server：Server 关闭连接

为什么挥手是四次？

虽然第二步服务端说了不再发送，但可能还会发送尾包，所以需要第三步去最终确认

## for...in 和 for...of 区别

1. 遍历对象：前者可以，后者不行
2. 遍历 Map/Set：前者不行，后者可以
3. 遍历 generator：前者不行，后者可以
4. 遍历数组/字符串：两者都可以

简而言之:

1. 前者遍历得到 key，后者遍历得到 value
2. 前者用于 **可枚举** 数据，后者用于 **可迭代** 数据

## for await... of 有什么用

用于遍历多个 Promise

```js
async function fn() {
  for await (let res of promises) {
    console.log(res)
  }
}
```

## offsetHeight/clientHeight/scrollHeight

offsetHeight = padding + content + border

clientHeight = padding + content

scrollHeight = padding + 实际内容尺寸

## HTMLCollection 和 NodeList 区别

1. DOM 是一棵树，所有节点都是 Node
2. Node 是 Element 的基类
3. Element 是其他 HTML 元素的基类

```js
class Node {}

// document
class Document extends Node {}
class DocumentFragment extends Node {}

// 文本和注释
class CharacterData extends Node {}
class Text extends CharacterData {}
class Comment extends CharacterData {}

// element
class Element extends Node {}
class HTMLElement extends Element {}
class HTMLDivElement extends HTMLElement {}
class HTMLButtonElement extends HTMLElement {}

const p = document.querySelector('p')
console.log(p.children instanceof HTMLCollection) // true
console.log(p.childNodes instanceof NodeList) // true

```

前者是 Element 的集合，后者是 Node 的集合

两者都是类数组，可以用 `Array.from(list)` / `Array.prototype.slice.call(list)` / `[...list]` 转换为数组

## 严格模式有什么特点

1. 全局变量必须先声明
2. 禁止用 with
3. 创建 eval 作用域
4. 禁止 this 指向 window
5. 函数参数不能重名

## HTTP 跨域请求为什么会发送 Options 请求

跨域请求：

1. 浏览器有同源策略
2. 同源策略一般限制 Ajax 请求，不能跨域请求 server
3. 但是不会限制 link/image/script/iframe 加载第三方资源

Options 请求是跨域请求前的预检查，是浏览器自行发起的，它会检查服务器是否允许跨域，不影响实际功能

## 内存泄露

垃圾回收 GC：

1. 引用计数(早期)：看是否被引用，如果没有被引用就清除，会有循环引用的问题
2. 标记清除(现代)：定期遍历根对象(比如 window)，看是否能得到某个对象，得不到就清除

PS：闭包不属于内存泄漏，因为闭包是可预期的，内存泄漏是不可预期的

如何检测内存泄漏：

通过 Chrome DevTools 的 Performance 面板，可以检测内存泄漏

```js
// 这个例子中如果多次执行 fn
// 就会导致多次的事件绑定
// 就会导致大量数据未被清除(obj被引用)
// 就会导致内存泄漏
function fn() {
  const obj = {
    // 大量数据
  }

  window.addEventListener('resize', () => {
    console.log(JSON.stringify(obj))
  })
}
```

## 内存泄漏场景

1. 数据被全局变量或全局函数引用，但没有及时清除
2. 定义了全局事件或定时器，但没有及时清除
3. 定义了自定义事件，但没有及时清除

## 浏览器和 node 的事件循环区别

单线程和异步：

1. JS 单线程(无论是在浏览器还是 node)
2. 浏览器 JS 执行和 DOM 渲染共用一个线程
3. 异步分宏任务和微任务，微任务在下一轮 DOM 渲染前执行，宏任务在渲染后执行，浏览器例子见 `Javascript.md`

浏览器和 node 事件循环区别：

1. 两者事件循环流程基本相同
2. 后者宏任务和微任务有细分类型，类型间有优先级，前者则没有
3. 后者推荐使用 setImmediate 代替 process.nextTick，推荐低优先级去执行异步

node 宏任务类型和优先级，从高到低排序：

1. Timer - setTimeout setInterval
2. I/O callbacks - 网络请求、流、TCP错误回调
3. Idle, prepare - 闲置状态 (node 内部使用)
4. Poll 轮询 - 执行 poll 中的 I/O 队列
5. Check 检查 - 存储 setImmediate 回调
6. Close callbacks - 关闭回调，如 socket.on('close')

node 微任务类型和优先级，从高到低排序：

1. process.nextTick
2. promise async/await

每个阶段的宏任务执行完都会执行微任务

```js
console.log(1)

setImmediate(() => {
  console.log(3)
})

setTimeout(() => {
  console.log(4)
})

Promise.resolve().then(() => {
  console.log(5)
})

process.nextTick(() => {
  console.log(6)
})

console.log(2)

// 1 2 6 5 4 3
```

## vdom 真的很快吗

1. vdom 并不快，JS 直接操作 DOM 速度更快
2. 但 “数据驱动视图” 要有合适的技术方案，不能全部 DOM 重建
3. vdom 就是最适合的技术方案(并不是因为快，而是因为合适)

## 遍历数组 for 和 forEach 哪个更快

前者更快一些，因为后者需要创建函数，而前者不需要，函数需要独立的作用域，会有额外开销

越 “低级” 的代码，性能往往更好

日常开发不一定只考虑性能，forEach 代码可读性更好

## Node 如何开启进程，进程如何通信

进程 process 和 线程 thread：

1. 前者是 OS 进行资源分配和调度的最小单位，有独立内存空间
2. 后者是 OS 进行运算调度的最小单位，共享进程内存空间
3. JS 是单线程的，但可以开启多进程执行，如 WebWorker

为何需要多进程：

1. 多进程可以充分利用多核 CPU
2. 多进程可以充分利用内存(单进程有内存上限)
3. 总之，多进程可以 “压榨” 机器资源

* child_process.fork 方式开启进程：

    ```js
    // index.js
    const http = require('http')
    const { fork } = require('child_process')


    const server = http.createServer((req, res) => {
      if (req.url === '/a') {
        console.log(process.pid) // 主进程ID

        // 开启子进程
        const worker = fork('./worker.js')
        // 发送信息给子进程
        worker.send('start')
        // 接收子进程信息
        worker.on('message', (res) => {
          console.log(res)
        })
        // 子进程错误处理
        worker.on('close', () => {
          console.log('worker error')
          worker.kill()
          res.end('error')
        })

        res.end('ok')
      }
    })

    server.listen(3000, () => {
      console.log('server is running')
    })
    ```

    ```js
    // worker.js
    function getSum() {
      let num = 0
      for (let i = 0; i < 1000000000; i++) {
        num += i
      }
      return num
    }

    // 接收主进程消息
    process.on('message', (msg) => {
      console.log(process.pid) // 子进程ID

      if (msg === 'start') {
        const sum = getSum()
        // 发送回给主进程
        process.send(sum)
      }
    })
    ```

* cluster.fork 方式开启进程：

    ```js
    // index.js
    const http = require('http')
    const cluster = require('cluster')
    const numCPUs = require('os').cpus().length

    if (cluster.isMaster) {
      console.log(`Master ${process.pid} is running`)
      for (let i = 0; i < numCPUs; i++) {
        // 开启子进程
        cluster.fork()
      }

      // 如果有进程挂掉，就再开启一个进程(进程守护)
      cluster.on('exit', (worker, code, signal) => {
        console.log(`worker ${worker.process.pid} died`)
        cluster.fork()
      })
    } else {
      const server = http.createServer((req, res) => {
        if (req.url === '/a') {
          console.log(process.pid)

          const res = getSum()
          console.log(res)

          res.end('ok')
        }
      })

      // 多个子进程会共享一个 TCP 连接，所以不会有端口占用的问题
      server.listen(3000, () => {
        console.log('server is running')
      })
    }
    ```

## requestIdleCallback 和 requestAnimationFrame 的区别

前者空闲时才执行，低优先级；后者每次渲染完都会执行，高优先级

两者都是宏任务，需要等待 DOM 渲染完才执行

## Vue2/Vue3/React 三者的 diff 算法区别

React 是 “仅右移”：

```js
// 以这个例子为例
// a b c d e
// b c a d e
// 1. 结果数据的 b 往左移动了一位，不管
// 2. 结果数据的 c 往左移动了一位，不管
// 3. 结果数据的 a 往右移动了两位，因为是右移，那就把 a 进行移动
// 4. a 移动后，b c 自动左移一位
```

Vue2 是 “双端比较”：

```js
// 类似 snabbdom 的方式，使用四个指针
// 分别指向 oldStart/oldEnd/newStart/newEnd，然后开始互相比较
// 这种方式的优势是：
// 比如有一个列表 a b c d
// 此时往 b c 之间插入 x y
// 得到 a b x y c d
// 使用这种方式可以很快的确定 a b c d 这四个元素没有发生变化
```

Vue3 是 “最长递增子序列”：

```js
// 最长递增子序列的意思就是数组中最长的递增的数的集合：
// 比如 [3, 5, 7, 1, 2, 8] 的最长递增子序列为 [3, 5, 7, 8]
// 以这个例子为例：
// a b c d e f g
// a b f c d e h g
// 1. 首先和 Vue2 的方式一样，四个指针比较，得到 a b g 是不变的
// 2. 接下来比较剩下的元素，原数据剩下的数据和索引是 [c d e f] -> [2 3 4 5]
// 3. 然后把索引代入到结果数据，设新增为 -1，得到 [f c d e h] -> [5 2 3 4 -1]
// 4. 得到结果数据的最长递增子序列为 [2 3 4]，即 c d e 是不变的
// 5. 最终只移动了 f 的位置，新增了 h 元素
```
