# 算法相关

## 什么是复杂度

1. 程序执行时需要的计算量和内存空间(和代码简洁无关)
2. 复杂度是数量级(方便记忆、推广)，不是具体数字
3. 一般针对一个具体的算法，而非完整的系统

复杂度排序：`n^2 > nlogn > n > logn > 1`

1. O(1)      一次就够(数量级)：比如 `return object[key]` 或 `return o.a + o.b + o.c`；`const a = 1`
2. O(logn)   数据量的对数(数量级)：比如二分查找
3. O(n)      和数据量一样(数量级)：比如单层 `for` 循环；`const a = [1, 2, 3]`
4. O(nlogn)  数据量 * 数据量的对数(数量级)：比如单层 `for` 循环 + 二分查找
5. O(n^2)    数据量的平方(数量级)：比如双层 `for` 循环

## 常用算法

### 冒泡排序

```java
// 冒泡排序
// 第一个循环通过检查数组的长度减去当前迭代的索引来决定应该进行多少趟排序。例如，如果数组有 n 个元素，那么第一个循环会运行 n-1 次，因为每次排序后最大的元素都会被放到末尾。
// 第二个循环负责两两比较相邻元素并且交换位置，如果前一个元素比后一个元素更大，则交换它们的位置。这个循环会随着外层循环的递增而缩短，因为每次外层循环之后，已经排好序的元素越来越多，所以内层循环的范围会逐渐减小。
public class BubbleSort {
    public static void sort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            // 外层循环控制排序的轮数
            for (int j = 0; j < arr.length - 1 - i; j++) {
                // 内层循环控制每一轮里的每一个比较步骤
                if (arr[j] > arr[j+1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = tmp;
                }
            }
        }
    }
}
```

### 把数组旋转 K 步

输入：`[1, 2, 3, 4, 5, 6, 7]`，`k = 3`
输出：`[5, 6, 7, 1, 2, 3, 4]`

两种思路：

1. 末尾元素挨个 pop，然后 unshift 到数组前面：时间复杂度 O(n^2)，空间复杂度 O(1)

    ```ts
    function rotate(nums: number[], k: number): number[] {
      const lenght = nums.length
      if (!k || length === 0) return nums
      const step = Math.abs(k % length)

      for (let i = 0; i < step; i++) {
        const last = nums.pop()
        // 数组是有序结构，unshift/shift/splice 会很慢，时间复杂度相当于单层 for 循环
        if (last != null) nums.unshift(last)
      }

      return nums
    }
    ```

2. 把数组拆分，然后 concat 到一起：时间复杂度 O(1)，空间复杂度 O(n)

    ```ts
    function rotate(nums: number[], k: number): number[] {
      const length = nums.length
      if (!k || length === 0) return nums
      const step = Math.abs(k % length)

      // slice 不会改变原数组，时间复杂度为 O(1)
      return nums.slice(step).concat(nums.slice(0, step))
    }
    ```

### 字符串括号匹配

输入：`a{b}c`
输出：`true`
输入：`a[b}c)`
输出：`false`

思路：

使用栈，遇到左括号入栈，遇到右括号匹配栈顶，匹配则出栈，不匹配就是失败，最后判断 length 是否为 0

时间复杂度 O(n)，空间复杂度 O(n)

```ts
function matchBrackets(str: string): boolean {
  const length = str.length
  if (length === 0) return true

  const stack = []
  const leftSymbols = '{[('
  const rightSymbols = '}])'

  for(let i = 0; i < length; i++) {
    const s = str[i]

    // 虽然 includes 时间复杂度是 O(n)
    // 但是 leftSymbols/rightSymbols 是固定的
    // 因此这里时间复杂度可以当作 O(1)
    if (leftSymbols.includes(s)) {
      stack.push(s)
    } else if (rightSymbols.includes(s)) {
      const top = stack[stack.length -1]

      if (
        top === '{' && s === '}' ||
        top === '[' && s === ']' ||
        top === '(' && s === ')'
      ) {
        stack.pop()
      } else {
        return false
      }
    }
  }

  return stack.length === 0
}
```

### 两个栈实现一个队列

思路：

stack1 用来入队，stack2 用来出队

比如 A B C 依次放入 stack1，得到

|C|
|B|
|A|
|_|stack1

然后把 stack1 的元素依次出栈到 stack2，得到

|A|
|B|
|C|
|_|stack2

最后 stack2 正常出栈，完成队列行为

假如出了 A 后马上加入 D，则需要把 stack2 的元素返回到 stack1，然后把 D 放入 stack1，得到

|D|
|C|
|B|
|_|stack1

后续同理

时间复杂度 add O(1) delete O(n)，空间复杂度 O(n)

```ts
class Queue {
  private stack1: number[] = []
  private stack2: number[] = []

  add(n: number) {
    this.stack1.push(n)
  }

  delete(): number | null {
    let res
    const stack1 = this.stack1
    const stack2 = this.stack2
    // 将 stack1 所有元素转移到 stack2
    while (stack1.length > 0) {
      stack2.push(stack1.pop())
    }
    // stack2 出栈
    res = stack2.pop()
    // 将 stack2 所有元素返回给 stack1
    while (stack2.length > 0) {
      stack1.push(stack2.pop())
    }
    return res || null
  }

  get length(): number {
    return this.stack1.length
  }
}
```

### 反转单向链表

